---
title: 计算机图形显示之-渲染管线
date: 2018-04-12 20:12
categories: blog
tags: [cg, pipeline]
---

> Rendering Pipeline这个东西我最开始接触的时候如果名字叫渲染流水线就会省去很多脑细胞去理解管线这个词是个什么东西。CPU的SuperPipeline就很人性化的翻译成超级流水线就很好理解。由于我接触cg的时候固定管线和可编程管线多地位和今天是相反的，所以处于礼貌的原因我也要先介绍一下固定管线，虽然从opengGL3.0就开始被剥离出去了，从应用的角度还是有必要拿出来说一下。

## 1.从厨师制作饼干开始我们的流水线之旅

[准备材料] => [制作好外形] => [烤箱内烘焙] => [🍪]

### 1.1.纯手工做饼干
全手工这个工作模式是每名厨师来全权负责整个流程的模式，从材料准备到饼干定型到烧火去烤全部工作都由一个人手工来完成，两名厨师没有分工没有流水完全并行的干自己的工作。优点是非常灵活想做成什么样的形状或者想要几成熟都可以实现，缺点也很明显就是效率底。

### 1.2.半自动化饼干
厨师想要偷懒买了蛋糕模具和可定时的烤箱。半自动化的工作模式可以看成是厨师用几种模具来做蛋糕，烤箱上也有8成熟/10成熟/12成熟几个选择按钮可以选。厨师负责用磨具给蛋糕定型，然后用烤箱负责烘焙。但是二者的工作是有依赖的可以流水但是不能并行，即厨师在定型的时候烤箱处于等待状态无法工作的，效率上比纯手工要快但是蛋糕的形状受制于模具的种类，如果没有某个形状的模具就不能做出相应的蛋糕。同理如果烤箱没有准备3成熟的按钮也同样烘焙不出需要的饼干。

### 1.3.可编程做饼干
可编程的工作模式就比较高级了，需要一个神奇的工具，这个工具不但功能是可以配置的，并且工作内容也是可编程的。这样的好处就是在饼干定型阶段这两个工具一起做饼干自动模具直接出需要的形状，并且形状是可以用程序控制的，在烘焙阶段也可以一起当烤箱去烘焙，并且烘焙的程度也是可以编程控制生产出颜色不同的饼干。如果只有两个工具提升效率的感觉可能还不明显如果有两百个这样的工具那么可编程的工作方式就很拽酷炫了。

## 2.说完饼干再来说说渲染的事

### 2.1.纯CPU渲染
这种方式CPU全权负责组织数据，定点变换和片元处理各个步骤，所有处理都是线性的并且都要占用cpu资源。

### 2.2.固定管线渲染
CUP太累了，找显卡帮忙去做渲染的事。固定管线的显卡由顶点渲染管线和像素渲染管线组成，生成图像的过程都是先由顶点渲染管线中的Vertex Shader（顶点着色器）生成基础的几何图形（由三角形构成），然后再由像素渲染管线中的Pixel Shader（像素着色器）进行填色，最后才是像素渲染管线中的纹理单元进行贴图。

把图元顶点位置和属性数据准备好（包括贴图/纹理坐标/关照/材质等等），把相应阶段的状态设定好然后开始渲染，等待屏幕出结果就可以了。比如定点变换，primitive的类型是点、线还是三角面亦或是三角条带，一次渲染这个设定好就不能修改了。这样顶点处理器和片元处理器有上下游关系，片元处理器要等待顶点处理器给它提供数据才能工作，这无疑降低了显卡的工作效率。

### 3.3.可编程管线渲染
显卡为了提高效率把每个处理器都磨练成全能的选手。统一渲染架构（Unified Shader）是相对于分离式渲染架构而言的。新的统一渲染架构，顶点着色器和像素着色器被合二为一，成为流处理器。流处理器，即着色单元（Pixel
Shader）就是那个众望所归的神奇的工具。它将同时负责顶点着色和像素着色，避免了附载不均衡的情况。（统一渲染架构中还增加了Geometry Shader）同架构显卡中，流处理器数量越多，性能也越强大。

对于一个着色单元里的一个运算单元（ALU）来说计算齐次坐标变换和计算argb的颜色融合其实差别不大没必要用一套闲一套。不论是顶点变换还是片元处理大家一起上。

> 以上两套东西可以参照着看，你可以把一个三维场景里的每个面片想象成一个饼干，在可编程管线处理过程中饼干的顶点和颜色都可以编程调整。调整顶点的程序片段叫顶点着色器，调整颜色的程序片段叫像素着色器。这些着色器最后被编译成可以在显卡内部的流处理器中运行的程序。

渲染流水线的起点是CPU从数据准备开始，终点是帧缓存，到显示器可能还要转换一下比如用VGA的液晶显示器，帧缓存的数字信号先转换成VAG模拟信号然后输入到显示器如果我没记错的化VGA的RGB分量是压缩过的565的比例损失了三分之一的信息但是这个比例是根据人眼的感光细胞优化过的感觉没那么糟糕，但是因为液晶是数字信号驱动的模拟信号还要在换回去，这就好比你用数码相机拍照洗出来再翻拍以后的效果，所以现在显卡上几乎看不到这个接口了。

``` python
#OpenGL 3.1主要新特性：
    Texture Buffer Objects(纹理缓冲对象)、
    Uniform Buffer Objects(统一缓冲对象)、
    Signed Normalized Textures(符号正常化纹理)、
    Primitive Restart(基本元素重启)、
    Instancing(实例化)、
    CopyBuffer API(拷贝缓冲接口)

#OpenGL 3.1删除的功能：
    固定管线
    选择反馈模式
    点画模式应用（实线虚线）
    alpha测试（用片段着色器替代)
``` 
